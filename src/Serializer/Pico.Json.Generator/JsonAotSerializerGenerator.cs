namespace Pico.Json.Generator;

[Generator]
public class JsonSerializerGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context
            .SyntaxProvider.CreateSyntaxProvider(
                predicate: static (s, _) => IsClassCandidate(s),
                transform: static (ctx, _) => GetClassSymbol(ctx)
            )
            .Where(static m => m != null);

        var compilationAndClasses = context.CompilationProvider.Combine(
            classDeclarations.Collect()
        );

        context.RegisterSourceOutput(
            compilationAndClasses,
            static (productionContext, source) =>
                Execute(source.Left, source.Right!, productionContext)
        );
    }

    private static bool IsClassCandidate(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax { Modifiers: var modifiers }
            && modifiers.Any(m => m.IsKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind.PublicKeyword))
            && !modifiers.Any(m =>
                m.IsKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind.StaticKeyword)
            );
    }

    private static INamedTypeSymbol? GetClassSymbol(GeneratorSyntaxContext context)
    {
        return context.SemanticModel.GetDeclaredSymbol(context.Node) as INamedTypeSymbol;
    }

    private static void Execute(
        Compilation compilation,
        IEnumerable<INamedTypeSymbol> classSymbols,
        SourceProductionContext context
    )
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("namespace Pico.Json.Generated;");
        sb.AppendLine("using Pico.Json;");
        sb.AppendLine();
        sb.AppendLine("public static partial class PicoJsonSerializer");
        sb.AppendLine("{");

        foreach (var type in classSymbols)
        {
            GenerateTypeMethods(type, sb);
        }

        sb.AppendLine("}");
        context.AddSource("PicoJsonSerializer.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static void GenerateTypeMethods(INamedTypeSymbol type, StringBuilder sb)
    {
        var properties = type.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && !p.IsStatic);

        sb.AppendLine(
            $$"""
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    internal static void Serialize{{type.Name}}(System.Text.StringBuilder sb, {{type}} value)
    {
        sb.EnsureCapacity(sb.Length + {{properties.Count() * 16}});
        sb.Append('{');
        bool first = true;
        {{GeneratePropertySerialization(properties)}}
        sb.Append('}');
    }
"""
        );

        sb.AppendLine(
            $$"""
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
    internal static {{type}} Deserialize{{type.Name}}(System.ReadOnlySpan<char> json, ref int index)
    {
        var obj = new {{type}}();
        JsonParser.SkipWhitespace(json, ref index);
        if (json[index++] != '{') throw new System.FormatException("Expected '{'");
        while (json[index] != '}')
        {
            {{GeneratePropertyDeserialization(properties)}}
            JsonParser.SkipWhitespace(json, ref index);
            if (json[index] == ',') index++;
        }
        index++;
        return obj;
    }
"""
        );
    }

    private static string GeneratePropertySerialization(IEnumerable<IPropertySymbol> properties)
    {
        var code = new StringBuilder();
        foreach (var prop in properties)
        {
            code.AppendLine(
                $$"""
                if (!first) sb.Append(',');
                first = false;
                sb.Append("\"{{prop.Name}}\":");
                {{GetSerializerForType(prop.Type, $"value.{prop.Name}")}}
                """
            );
        }
        return code.ToString();
    }

    private static string GetSerializerForType(ITypeSymbol type, string accessor) =>
        type.SpecialType switch
        {
            SpecialType.System_String => $"JsonWriter.WriteString(sb, {accessor});",
            SpecialType.System_Int32 => $"JsonWriter.WriteNumber(sb, {accessor});",
            SpecialType.System_Boolean => $"JsonWriter.WriteBool(sb, {accessor});",
            _ => $"PicoJsonSerializer.Serialize(sb, {accessor});"
        };

    private static string GeneratePropertyDeserialization(IEnumerable<IPropertySymbol> properties)
    {
        var code = new StringBuilder();
        code.AppendLine(
            $$"""
                var key = JsonParser.ParseStringSpan(json, ref index);
                JsonParser.SkipWhitespace(json, ref index);
                if (json[index++] != ':') throw new System.FormatException("Expected ':'");
                switch(key)
                {
                    {{GeneratePropertyCases(properties)}}
                    default: JsonParser.SkipValue(json, ref index); break;
                }
            """
        );
        return code.ToString();
    }

    private static string GeneratePropertyCases(IEnumerable<IPropertySymbol> properties)
    {
        var code = new StringBuilder();
        foreach (var prop in properties)
        {
            code.AppendLine(
                $$"""
                    case var _ when key.SequenceEqual("{{prop.Name}}".AsSpan()):
                        obj.{{prop.Name}} = {{GetDeserializerForType(prop.Type)}};
                        break;
                """
            );
        }
        return code.ToString();
    }

    private static string GetDeserializerForType(ITypeSymbol type) =>
        type.SpecialType switch
        {
            SpecialType.System_String => "JsonParser.ParseStringSpan(json, ref index).ToString()",
            SpecialType.System_Int32 => "JsonParser.ParseInt(json, ref index)",
            SpecialType.System_Boolean => "JsonParser.ParseBool(json, ref index)",
            _ => $"PicoJsonSerializer.Deserialize<{type}>(json, ref index)"
        };
}
