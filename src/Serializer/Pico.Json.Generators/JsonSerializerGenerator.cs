using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Pico.Json.Generators;

[Generator(LanguageNames.CSharp)]
public sealed class JsonSerializerGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context
            .SyntaxProvider.CreateSyntaxProvider(
                predicate: static (s, _) =>
                    s is ClassDeclarationSyntax cds
                    && cds.Members.OfType<PropertyDeclarationSyntax>().Any(),
                transform: static (ctx, _) => (ClassDeclarationSyntax)ctx.Node
            )
            .Where(c => c != null);

        var compilationAndClasses = context.CompilationProvider.Combine(
            classDeclarations.Collect()
        );

        context.RegisterSourceOutput(
            compilationAndClasses,
            (spc, source) => Execute(spc, source.Left, source.Right)
        );
    }

    private void Execute(
        SourceProductionContext context,
        Compilation compilation,
        IEnumerable<ClassDeclarationSyntax> classes
    )
    {
        foreach (var classDecl in classes.Distinct())
        {
            var semanticModel = compilation.GetSemanticModel(classDecl.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol typeSymbol)
                continue;

            if (!HasSerializableProperties(typeSymbol))
                continue;

            var source = GenerateSerializerSource(typeSymbol);
            context.AddSource(
                $"{typeSymbol.Name}Serializer.g.cs",
                SourceText.From(source, Encoding.UTF8)
            );
        }
    }

    private bool HasSerializableProperties(INamedTypeSymbol typeSymbol)
    {
        return typeSymbol
            .GetMembers()
            .OfType<IPropertySymbol>()
            .Any(p =>
                p.DeclaredAccessibility == Accessibility.Public
                && !p.IsReadOnly
                && p.SetMethod != null
            );
    }

    private string GenerateSerializerSource(INamedTypeSymbol typeSymbol)
    {
        var typeName = typeSymbol.ToDisplayString();
        var properties = GetSerializableProperties(typeSymbol);

        return $$"""
            // <auto-generated/>
            using System.IO;
            using System.Text;

            namespace Pico.Json
            {
                public static partial class JsonSerializer
                {
                    private static partial class SerializerCache<{{typeName}}>
                    {
                        public static void Serialize(Stream stream, {{typeName}} value)
                        {
                            using var writer = new StreamWriter(stream, Encoding.UTF8, leaveOpen: true);
                            writer.Write("{");
                            {{BuildSerializeBody(properties)}}
                            writer.Write("}");
                        }

                        public static {{typeName}} Deserialize(Stream stream)
                        {
                            using var reader = new StreamReader(stream, Encoding.UTF8, leaveOpen: true);
                            var json = reader.ReadToEnd();
                            var obj = new {{typeName}}();
                            {{BuildDeserializeBody(properties)}}
                            return obj;
                        }
                    }
                }
            }
            """;
    }

    private string BuildSerializeBody(IEnumerable<IPropertySymbol> properties)
    {
        var sb = new StringBuilder();
        var first = true;

        foreach (var prop in properties)
        {
            if (!first)
                sb.AppendLine("writer.Write(\",\");");
            first = false;

            sb.AppendLine($@"writer.Write($""\""{prop.Name}\"":"");");

            if (prop.Type.SpecialType == SpecialType.System_String)
            {
                sb.AppendLine(
                    $@"writer.Write($""\""{{Pico.Json.JsonStringHelper.Escape(value.{prop.Name})}}\"""");"
                );
            }
            else
            {
                sb.AppendLine($@"writer.Write(value.{prop.Name}.ToString());");
            }
        }

        return sb.ToString();
    }

    private string BuildDeserializeBody(IEnumerable<IPropertySymbol> properties)
    {
        var sb = new StringBuilder();
        foreach (var prop in properties)
        {
            var parseExpr = prop.Type.SpecialType switch
            {
                SpecialType.System_String => "__value.Trim('\"')",
                SpecialType.System_Int32 => "int.Parse(__value)",
                SpecialType.System_Boolean => "bool.Parse(__value)",
                SpecialType.System_Double => "double.Parse(__value)",
                _ => $"default({prop.Type})"
            };

            sb.AppendLine(
                $$"""
                if (TryGetValue(json, "{{prop.Name}}", out var __value))
                {
                    obj.{{prop.Name}} = {{parseExpr}};
                }
                """
            );
        }
        return sb.ToString();
    }

    private static List<IPropertySymbol> GetSerializableProperties(INamedTypeSymbol typeSymbol)
    {
        return typeSymbol
            .GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public)
            .Where(p => !p.IsReadOnly)
            .Where(p => p.SetMethod != null)
            .ToList();
    }
}
