namespace PicoHex.IoC.Generator;

/// <inheritdoc />
[Generator]
public class IoCSourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new ConstructorSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxContextReceiver is not ConstructorSyntaxReceiver receiver)
            return;

        var sourceCode = GenerateFactoryProvider(receiver.ConstructorClasses);
        context.AddSource(
            "GeneratedFactoryProvider.g.cs",
            SourceText.From(sourceCode, Encoding.UTF8)
        );
    }

    private static string GenerateFactoryProvider(IEnumerable<INamedTypeSymbol> constructorClasses)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// This code was generated by the PicoHex.IoC.Generator");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine();
        sb.AppendLine("namespace PicoHex.IoC");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Generated factory provider for IoC container");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public class GeneratedFactoryProvider : IFactoryProvider");
        sb.AppendLine("    {");
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Registers all generated factories with the container");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine(
            "        public void RegisterFactories(ServiceContainer container, Dictionary<Type, Func<ServiceContainer, object>> factories)"
        );
        sb.AppendLine("        {");

        foreach (var classSymbol in constructorClasses)
        {
            var constructor = classSymbol
                .Constructors.Where(c => c.DeclaredAccessibility == Accessibility.Public)
                .OrderByDescending(c => c.Parameters.Length)
                .FirstOrDefault();

            if (constructor == null)
                continue;

            var fullTypeName = classSymbol.ToDisplayString(
                new SymbolDisplayFormat(
                    typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces
                )
            );

            sb.AppendLine($"            factories[typeof({fullTypeName})] = container =>");
            sb.AppendLine("            {");

            var parameters = new List<string>();
            foreach (var parameter in constructor.Parameters)
            {
                var paramType = parameter.Type.ToDisplayString(
                    new SymbolDisplayFormat(
                        typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces
                    )
                );

                parameters.Add($"({paramType})container.GetService(typeof({paramType}))");
            }

            var parameterList = string.Join(", ", parameters);
            sb.AppendLine($"                return new {fullTypeName}({parameterList});");
            sb.AppendLine("            };");
        }

        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }
}

/// <summary>
/// Collects classes with constructors that have parameters
/// </summary>
public class ConstructorSyntaxReceiver : ISyntaxContextReceiver
{
    public readonly List<INamedTypeSymbol> ConstructorClasses = new List<INamedTypeSymbol>();

    public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
    {
        if (context.Node is not ClassDeclarationSyntax classDeclaration)
            return;
        var symbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);
        if (symbol == null)
            return;

        if (symbol.IsAbstract || symbol.DeclaredAccessibility != Accessibility.Public)
            return;

        var hasConstructorWithParams = symbol.Constructors.Any(c =>
            c.Parameters.Length > 0 && c.DeclaredAccessibility == Accessibility.Public
        );

        if (hasConstructorWithParams)
        {
            ConstructorClasses.Add(symbol);
        }
    }
}
