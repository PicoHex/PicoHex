namespace PicoHex.IoC.Generator
{
    [Generator]
    public class IoCSourceGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            // Register a simple syntax receiver
            context.RegisterForSyntaxNotifications(() => new ConstructorSyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            // Cast the context receiver to our syntax receiver
            if (!(context.SyntaxContextReceiver is ConstructorSyntaxReceiver receiver))
                return;

            // Generate the implementation class
            var sourceCode = GenerateFactoryImplementation(
                receiver.ConstructorClasses,
                context.Compilation
            );

            // Add the source code to the compilation
            context.AddSource("ServiceContainer.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
        }

        private string GenerateFactoryImplementation(
            IEnumerable<INamedTypeSymbol> constructorClasses,
            Compilation compilation
        )
        {
            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated>");
            sb.AppendLine("// This code was generated by the PicoHex.IoC.Generator");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine("#pragma warning disable CS1591");
            sb.AppendLine("using System;");
            sb.AppendLine();
            sb.AppendLine("namespace PicoHex.IoC");
            sb.AppendLine("{");
            sb.AppendLine("    public partial class ServiceContainer");
            sb.AppendLine("    {");
            sb.AppendLine("        private void RegisterGeneratedFactories()");
            sb.AppendLine("        {");

            foreach (var classSymbol in constructorClasses)
            {
                // Get the most appropriate constructor (the one with the most parameters)
                var constructor = classSymbol
                    .Constructors.Where(c => c.DeclaredAccessibility == Accessibility.Public)
                    .OrderByDescending(c => c.Parameters.Length)
                    .FirstOrDefault();

                if (constructor == null)
                    continue;

                var fullTypeName = classSymbol.ToDisplayString(
                    new SymbolDisplayFormat(
                        typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces
                    )
                );

                sb.AppendLine($"            _factories[typeof({fullTypeName})] = container =>");
                sb.AppendLine("            {");

                var parameters = new List<string>();
                foreach (var parameter in constructor.Parameters)
                {
                    var paramType = parameter.Type.ToDisplayString(
                        new SymbolDisplayFormat(
                            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces
                        )
                    );

                    parameters.Add($"({paramType})container.GetService(typeof({paramType}))");
                }

                var parameterList = string.Join(", ", parameters);
                sb.AppendLine($"                return new {fullTypeName}({parameterList});");
                sb.AppendLine("            };");
            }

            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");
            sb.AppendLine("#pragma warning restore CS1591");

            return sb.ToString();
        }
    }

    /// <summary>
    /// Simple syntax receiver that collects classes with constructors that have parameters
    /// </summary>
    public class ConstructorSyntaxReceiver : ISyntaxContextReceiver
    {
        public readonly List<INamedTypeSymbol> ConstructorClasses = new List<INamedTypeSymbol>();

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            // We're only interested in class declarations
            if (context.Node is ClassDeclarationSyntax classDeclaration)
            {
                // Get the semantic model for the class
                var symbol =
                    context.SemanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;
                if (symbol == null)
                    return;

                // Only include concrete public classes
                if (symbol.IsAbstract || symbol.DeclaredAccessibility != Accessibility.Public)
                    return;

                // Check if the class has a constructor with parameters
                var hasConstructorWithParams = symbol.Constructors.Any(c =>
                    c.Parameters.Length > 0 && c.DeclaredAccessibility == Accessibility.Public
                );

                if (hasConstructorWithParams)
                {
                    ConstructorClasses.Add(symbol);
                }
            }
        }
    }
}
