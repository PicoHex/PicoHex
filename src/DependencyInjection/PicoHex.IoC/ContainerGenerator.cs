using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace PicoHex.IoC;

[Generator]
public class ContainerGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // 使用安全模式注册语法接收器
        context.RegisterForSyntaxNotifications(() => new SyntaxCollector());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        // 1. 收集所有候选类型
        var collector = new TypeCollector(context);
        var registrations = collector.CollectRegistrations();

        // 2. 生成注册代码
        GenerateRegistrationCode(context, registrations);
    }

    private void GenerateRegistrationCode(
        GeneratorExecutionContext context,
        IEnumerable<TypeRegistration> registrations
    )
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine();
        sb.AppendLine("namespace GeneratedIoC");
        sb.AppendLine("{");
        sb.AppendLine("    public static class ContainerRegistration");
        sb.AppendLine("    {");
        sb.AppendLine("        public static void Register(ContainerBuilder builder)");
        sb.AppendLine("        {");

        foreach (var reg in registrations)
        {
            sb.AppendLine($"            // {reg.ImplementationType}");
            sb.AppendLine(
                $"            builder.Register<{reg.InterfaceType}, {reg.ImplementationType}>();"
            );
        }

        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource(
            "ContainerRegistration.g.cs",
            SourceText.From(sb.ToString(), Encoding.UTF8)
        );
    }
}

internal class TypeCollector
{
    private readonly GeneratorExecutionContext _context;

    public TypeCollector(GeneratorExecutionContext context)
    {
        _context = context;
    }

    public IEnumerable<TypeRegistration> CollectRegistrations()
    {
        foreach (var syntaxTree in _context.Compilation.SyntaxTrees)
        {
            var semanticModel = _context.Compilation.GetSemanticModel(syntaxTree);
            var classDeclarations = syntaxTree
                .GetRoot()
                .DescendantNodes()
                .OfType<ClassDeclarationSyntax>();

            foreach (var classDecl in classDeclarations)
            {
                var classSymbol =
                    ModelExtensions.GetDeclaredSymbol(semanticModel, classDecl) as INamedTypeSymbol;
                if (IsValidRegistration(classSymbol))
                {
                    yield return CreateRegistration(classSymbol!);
                }
            }
        }
    }

    private bool IsValidRegistration(INamedTypeSymbol? symbol)
    {
        return symbol != null
            && symbol.DeclaredAccessibility == Accessibility.Public
            && !symbol.IsAbstract
            && symbol.Constructors.Any(c => c.DeclaredAccessibility == Accessibility.Public);
    }

    private TypeRegistration CreateRegistration(INamedTypeSymbol classSymbol)
    {
        var interfaceType =
            classSymbol
                .Interfaces.FirstOrDefault(i => i.Name == $"I{classSymbol.Name}")
                ?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            ?? classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        return new TypeRegistration(
            interfaceType,
            classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
        );
    }
}

internal record TypeRegistration(string InterfaceType, string ImplementationType);

internal class SyntaxCollector : ISyntaxReceiver
{
    public List<ClassDeclarationSyntax> Classes { get; } = new();

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        if (
            syntaxNode is ClassDeclarationSyntax classDecl
            && classDecl.Modifiers.Any(m => m.IsKind(SyntaxKind.PublicKeyword))
        )
        {
            Classes.Add(classDecl);
        }
    }
}
