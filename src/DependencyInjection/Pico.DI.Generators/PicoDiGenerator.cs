using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Pico.DI.Generators;

[Generator]
public sealed class PicoDiGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var registrations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (n, _) => n is InvocationExpressionSyntax,
                transform: static (ctx, _) => TryMatchRegistration(ctx)
            )
            .Where(static m => m is not null)!
            .Collect();

        context.RegisterSourceOutput(registrations, static (spc, list) =>
        {
            var items = list!.OfType<Registration>().ToImmutableArray();
            if (items.Length == 0)
            {
                spc.AddSource("SvcFactory.g.cs", SourceText.From(EmitEmptyStub(), System.Text.Encoding.UTF8));
                return;
            }

            var grouped = items.Distinct().ToImmutableArray();
            spc.AddSource("SvcFactory.g.cs", SourceText.From(EmitFactory(grouped), System.Text.Encoding.UTF8));
        });
    }

    private static object? TryMatchRegistration(GeneratorSyntaxContext ctx)
    {
        var invocation = (InvocationExpressionSyntax)ctx.Node;
        if (ctx.SemanticModel.GetSymbolInfo(invocation).Symbol is not IMethodSymbol ms)
            return null;

        if (ms.ContainingType is null)
            return null;

        if (ms.ContainingType.ToDisplayString() != "Pico.DI.Abs.SvcContainerExtensions")
            return null;

        // 支持的方法名前缀
        var name = ms.Name;
        if (!name.StartsWith("Register", StringComparison.Ordinal))
            return null;

        // 仅处理 service/impl 为可静态解析的情况（泛型参数或 typeof）
        ITypeSymbol? service = null;
        ITypeSymbol? impl = null;

        // 泛型 Register<TService, TImplementation>()
        if (ms.IsGenericMethod && ms.TypeArguments.Length >= 1)
        {
            service = ms.TypeArguments[0];
            if (ms.TypeArguments.Length >= 2)
                impl = ms.TypeArguments[1];
        }

        // 非泛型重载：参数中含 typeof(...)
        if (impl is null)
        {
            foreach (var arg in invocation.ArgumentList.Arguments)
            {
                var type = TryGetTypeFromExpr(ctx.SemanticModel, arg.Expression);
                if (type is null) continue;

                if (service is null) { service = type; continue; }
                if (impl is null) { impl = type; break; }
            }
        }

        if (service is null)
            return null;

        impl ??= service; // self-binding 场景

        // 排除运行时变量或无法访问类型
        if (service.TypeKind == TypeKind.Error || impl.TypeKind == TypeKind.Error)
            return null;

        return new Registration(
            Service: service,
            Implementation: impl
        );
    }

    private static ITypeSymbol? TryGetTypeFromExpr(SemanticModel model, ExpressionSyntax expr)
    {
        // typeof(T)
        if (expr is TypeOfExpressionSyntax toe)
            return model.GetTypeInfo(toe.Type).Type;

        // 支持 nameof 不必要；忽略
        return null;
    }

    private static string EmitEmptyStub() =>
@"// <auto-generated/>
namespace Pico.DI.Internal
{
    internal static partial class SvcFactory
    {
        internal static partial bool TryGetGeneratedFactory(
            Pico.DI.Abs.SvcDescriptor descriptor,
            out System.Func<Pico.DI.Abs.ISvcProvider, object> factory)
        {
            factory = default!;
            return false;
        }
    }
}
";

    private static string EmitFactory(ImmutableArray<Registration> regs)
    {
        var sb = new System.Text.StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using Pico.DI.Abs;");
        sb.AppendLine("namespace Pico.DI.Internal");
        sb.AppendLine("{");
        sb.AppendLine("    internal static partial class SvcFactory");
        sb.AppendLine("    {");
        sb.AppendLine("        internal static partial bool TryGetGeneratedFactory(SvcDescriptor descriptor, out System.Func<ISvcProvider, object> factory)");
        sb.AppendLine("        {");
        sb.AppendLine("            var t = descriptor.ServiceType;");

        foreach (var r in regs)
        {
            var s = r.Service.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var i = r.Implementation.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            // 选择构造器（参数最多）
            var ctor = r.Implementation
                .InstanceConstructors
                .Where(c => c.DeclaredAccessibility == Accessibility.Public)
                .OrderByDescending(c => c.Parameters.Length)
                .FirstOrDefault();

            if (ctor is null) continue;

            var args = string.Join(
                ", ",
                ctor.Parameters.Select(p => $"global::Pico.DI.Abs.SvcResolverExtensions.Resolve<{p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>(sp)")
            );

            sb.AppendLine($"            if (t == typeof({s}))");
            sb.AppendLine("            {");
            sb.AppendLine($"                factory = static sp => new {i}({args});");
            sb.AppendLine("                return true;");
            sb.AppendLine("            }");
        }

        sb.AppendLine("            factory = default!; return false;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private readonly record struct Registration(ITypeSymbol Service, ITypeSymbol Implementation);
}